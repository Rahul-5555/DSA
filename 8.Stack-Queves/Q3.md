# ğŸš€ LeetCode 232 â€“ Implement Queue using Stacks

## ğŸ“Œ Problem
Implement a Queue using two Stacks.

Queue follows **FIFO (First In First Out)** principle.  
Stack follows **LIFO (Last In First Out)** principle.

---

## ğŸ§  Approach

We use **two stacks**:

- `s1` â†’ Used for push operations
- `s2` â†’ Used for pop and peek operations

### ğŸ”¹ Push Operation

Push the element directly into stack `s1`.

### ğŸ”¹ Pop Operation

If `s2` is empty:
- Transfer all elements from `s1` to `s2`
- This reverses the order

Then pop from `s2`.

### ğŸ”¹ Peek Operation

If `s2` is empty:
- Transfer all elements from `s1` to `s2`

Return the top element of `s2`.

### ğŸ”¹ Empty Operation

Return true if both stacks are empty.

---

## ğŸ’» Implementation (JavaScript)

```javascript
var MyQueue = function () {
  this.s1 = [];
  this.s2 = [];
};

MyQueue.prototype.push = function (x) {
  this.s1.push(x);
};

MyQueue.prototype.pop = function () {
  if (this.s2.length === 0) {
    while (this.s1.length) {
      this.s2.push(this.s1.pop());
    }
  }
  return this.s2.pop();
};

MyQueue.prototype.peek = function () {
  if (this.s2.length === 0) {
    while (this.s1.length) {
      this.s2.push(this.s1.pop());
    }
  }
  return this.s2[this.s2.length - 1];
};

MyQueue.prototype.empty = function () {
  return this.s1.length === 0 && this.s2.length === 0;
};
```

---

## â± Time Complexity

| Operation | Complexity     |
| --------- | -------------- |
| push()    | O(1)           |
| pop()     | O(1) amortized |
| peek()    | O(1) amortized |
| empty()   | O(1)           |

### ğŸ” Why Amortized O(1)?

Each element:
- Is pushed once to `s1`
- Moved once to `s2`
- Popped once

So total operations are linear â†’ average O(1).

---

## âœ… Key Concept

By transferring elements only when `s2` is empty,  
we avoid unnecessary operations and achieve optimal performance.

---

ğŸ”¥ Happy Coding!

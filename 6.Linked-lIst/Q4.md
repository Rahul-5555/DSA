//234- leetcode: Palindrome linked list
/*
ğŸ”´ Problem: Palindrome Linked List (LeetCode 234)

Linked list palindrome hai ya nahi check karna
(forward aur backward same values honi chahiye)

Example:

1 â†’ 2 â†’ 2 â†’ 1 âœ…

1 â†’ 2 â†’ 3 âŒ


*/

var isPalindrome = function (head) {
  // finding the middle element
  let slow = fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  // reverse the second half of the linked list
  let prev = null;
  let curr = slow;
  while (curr) {
    let temp = curr.next;
    curr.next = prev;
    prev = curr;
    curr = temp;
  }

  // checking for palindrome
  let firstList = head;  // start node
  let secondList = prev;  // last node
  while(secondList){
    if(firstList.val != secondList.val){
      return false;
    }
    firstList = firstList.next;
    secondList = secondList.next;
  }
  return true;
}



/*
Great question ğŸ‘

## ğŸ”´ Problem: Palindrome Linked List (LeetCode 234)

> Linked list **palindrome** hai ya nahi check karna
> (forward aur backward same values honi chahiye)

Example:

* `1 â†’ 2 â†’ 2 â†’ 1` âœ…
* `1 â†’ 2 â†’ 3` âŒ

---

## ğŸ§© Problem ko 3 Sub-Problems me divide karo

### **Sub-Problem 1ï¸âƒ£: Middle node dhoondhna**

ğŸ‘‰ List ko 2 parts me todna

```js
let slow = fast = head;
while (fast && fast.next) {
  slow = slow.next;
  fast = fast.next.next;
}
```

**Logic**

* `slow` â†’ 1 step
* `fast` â†’ 2 steps
* Jab `fast` end pe pahunchta hai â†’ `slow` middle pe hota hai

---

### **Sub-Problem 2ï¸âƒ£: Second half reverse karna**

Perfect ğŸ‘
Main **sirf logic** explain kar raha hoon â€” **no extra theory**, **simple Hinglish**, **interview-ready**.

---

## ğŸ§© Sub-Problem 2ï¸âƒ£: Second Half Reverse Karna (CORE LOGIC)

### â“ WHY reverse?

Linked List me **backward traversal possible nahi hota**.
Palindrome check karne ke liye hume **last element se compare** karna hota hai.

ğŸ‘‰ **Solution:** second half ko reverse kar do.

---

### ğŸ”‘ Reverse ka basic idea

```
Original:  2 â†’ 1 â†’ null
Reversed:  1 â†’ 2 â†’ null
```

---

### ğŸ§  Mindset (important)

* Har node ka `next` pointer **peeche ki taraf mod do**
* 3 pointers ka use:

  * `prev` â†’ pichhla node
  * `curr` â†’ current node
  * `temp` â†’ next node ko safe rakhne ke liye

---

### ğŸ” Step-by-step logic (line by line)

```js
let prev = null;
let curr = slow;
```

* `prev` = null (kyunki first node ka next null hota hai)
* `curr` = middle se start kar rahe hain

---

```js
let temp = curr.next;
```

ğŸ‘‰ Next node ko **save** kar liya
(nahi to link toot jaayega)

---

```js
curr.next = prev;
```

ğŸ‘‰ Current node ka arrow **peeche mod diya**

---

```js
prev = curr;
curr = temp;
```

ğŸ‘‰

* `prev` aage badha
* `curr` next node pe chala gaya

---

### ğŸ” Loop jab tak `curr` null na ho

ğŸ‘‰ End me:

```
prev â†’ reversed list ka head
```

---

## ğŸ§© Sub-Problem 3ï¸âƒ£: Dono Halves Compare Karna (CORE LOGIC)

### â“ WHY comparison?

Ab:

* First half â†’ normal order
* Second half â†’ reverse order

ğŸ‘‰ Agar palindrome hoga â†’ dono same honge

---

### ğŸ”‘ Comparison ka idea

```
1 â†’ 2 â†’ 2 â†’ 1
â†‘         â†‘
start     reversed start
```

---

### ğŸ§  Logic mindset

* Ek pointer start se
* Ek pointer end se
* Values same nahi â†’ âŒ palindrome nahi

---

### ğŸ” Step-by-step logic

```js
let firstList = head;
let secondList = prev;
```

* `firstList` â†’ list ka start
* `secondList` â†’ reversed second half ka start

---

```js
while (secondList) {
```

ğŸ‘‰ Sirf second list tak loop
(odd length me middle ignore ho jaata hai automatically)

---

```js
if (firstList.val != secondList.val) {
  return false;
}
```

ğŸ‘‰ Ek bhi mismatch mila â†’ turant âŒ

---

```js
firstList = firstList.next;
secondList = secondList.next;
```

ğŸ‘‰ Dono pointers aage badhte jao

---

### ğŸŸ¢ Loop khatam = Palindrome confirmed

```js
return true;
```

---

## ğŸ§  One-Line Interview Logic (BEST)

### ğŸ”¹ Reverse Logic:

> â€œWe reverse the second half so we can compare nodes from both ends.â€

### ğŸ”¹ Compare Logic:

> â€œWe compare the first half and reversed second half node by node.â€



## ğŸ” Dry Run (Step-by-Step)

### âœ… Case 1: **Even length palindrome**

```
1 â†’ 2 â†’ 2 â†’ 1
```

### ğŸ”¹ Step 1: Find middle

| slow | fast |
| ---- | ---- |
| 1    | 1    |
| 2    | 2    |
| 2    | null |

ğŸ‘‰ `slow` = **3rd node (2)**

---

### ğŸ”¹ Step 2: Reverse second half

```
Original second half: 2 â†’ 1
Reversed: 1 â†’ 2
```

---

### ğŸ”¹ Step 3: Compare

| firstList | secondList |
| --------- | ---------- |
| 1         | 1          |
| 2         | 2          |

âœ” Match â†’ **Palindrome**

---

## ğŸ” Dry Run (Odd length)

### âœ… Case 2: **Odd length palindrome**

```
1 â†’ 2 â†’ 3 â†’ 2 â†’ 1
```

### ğŸ”¹ Middle:

* `slow` points to `3`

### ğŸ”¹ Reverse from `3`

```
3 â†’ 2 â†’ 1
â¬‡
1 â†’ 2 â†’ 3
```

### ğŸ”¹ Compare:

```
1 == 1
2 == 2
(stop because secondList finished)
```

âœ” Palindrome

ğŸ‘‰ **Middle element ignore ho jaata hai automatically**

---

## âš ï¸ Corner Cases (VERY IMPORTANT)

### ğŸŸ¡ Case 1: Empty list

```
head = null
```

âœ” Palindrome (no elements)

---

### ğŸŸ¡ Case 2: Single node

```
1
```

âœ” Always palindrome

---

### ğŸŸ¡ Case 3: Two nodes (not palindrome)

```
1 â†’ 2
```

âŒ Values mismatch â†’ return false

---

### ğŸŸ¡ Case 4: All same values

```
2 â†’ 2 â†’ 2 â†’ 2
```

âœ” Palindrome

---

### ğŸŸ¡ Case 5: Non-palindrome

```
1 â†’ 2 â†’ 3 â†’ 4
```

âŒ Mismatch at first comparison

---

## â± Time & Space Complexity

| Type  | Complexity                     |
| ----- | ------------------------------ |
| Time  | **O(n)**                       |
| Space | **O(1)** (no extra array used) |

ğŸ‘‰ Interviewers **LOVE this approach**

---

## ğŸ¯ Interview Me Kaise Bolna

> â€œFirst I find the middle using slow & fast pointers.
> Then I reverse the second half of the list.
> Finally, I compare both halves node by node.
> If all values match, the linked list is a palindrome.â€

---


*/
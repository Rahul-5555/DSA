Perfect ğŸ‘
Main **LeetCode 203 â€“ Remove Linked List Elements** ko **line-by-line**, **mindset**, aur **dry-run thinking** ke saath explain kar raha hoon â€” **simple Hinglish**, interview-ready.

---

## ğŸ”´ Problem (Short)

Linked list se **saare nodes remove karo** jinki value `val` ke equal ho.

Example:

```
Input:  1 â†’ 2 â†’ 6 â†’ 3 â†’ 6 â†’ 4 , val = 6
Output: 1 â†’ 2 â†’ 3 â†’ 4
```

---

## ğŸ§  Core Mindset (MOST IMPORTANT)

> **Head ko delete karna sabse tricky hota hai.**
> Isliye hum **sentinel (dummy) node** use karte hain taaki head bhi normal node jaisa behave kare.

---

## ğŸ§© Visual Intuition (Sentinel Trick)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220527103848/sentinelnodes-660x242.jpg)

![Image](https://www.cs.dartmouth.edu/~scot/cs10/lectures/6/remove-from-big-DLL.gif)

```
sentinel â†’ head â†’ 1 â†’ 2 â†’ 6 â†’ 3
```

ğŸ‘‰ Ab deletion **uniform** ho jaata hai (head ho ya middle).

---

## âœ… Tumhara Code

```js
var removeElement = function (head, val) {
  let sentinel = new ListNode(); // make a sentinel node
  sentinel.next = head;         // sentinel next node is head

  let prev = sentinel;          // tracking prev equal to sentinel
  while (prev && prev.next) {
    if (prev.next.val === val) {
      prev.next = prev.next.next;
    }
    else {
      prev = prev.next;
    }
  }
  return sentinel.next;
}
```

---

## ğŸ” Line-by-Line Explanation + Logic

### 1ï¸âƒ£ Sentinel (Dummy) Node

```js
let sentinel = new ListNode();
sentinel.next = head;
```

**Logic / Mindset**

* Sentinel ek **fake node** hai
* Ye real head ke **pehle** lagta hai
* Agar head ko delete karna pade â†’ code simple rehta hai

ğŸ‘‰ Without sentinel:

* Head delete = special case ğŸ˜µ
  ğŸ‘‰ With sentinel:
* **No special case** ğŸ˜

---

### 2ï¸âƒ£ `prev` pointer

```js
let prev = sentinel;
```

**Logic**

* `prev` hamesha **current node ke pichhe** rahega
* Hum actually **`prev.next` ko check** karte hain

ğŸ§  Rule:

> â€œDeletion hamesha prev ke through hoti haiâ€

---

### 3ï¸âƒ£ Traversal Loop

```js
while (prev && prev.next) {
```

**Why `prev.next`?**

* Kyunki hum **next node delete** kar sakte hain
* `prev` khud kabhi delete nahi hota

---

### 4ï¸âƒ£ Deletion Condition

```js
if (prev.next.val === val) {
  prev.next = prev.next.next;
}
```

**Logic**

* Agar next node ki value `val` hai
  ğŸ‘‰ Us node ko **skip** kar do

```
Before: prev â†’ [X] â†’ next
After:  prev â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ next
```

ğŸ§  Important:

* `prev` **move nahi hota**
* Kyunki ho sakta hai next node bhi delete karna ho

---

### 5ï¸âƒ£ Move `prev` normally

```js
else {
  prev = prev.next;
}
```

**Logic**

* Jab deletion nahi hota
* Tab prev ko aage badhao

---

### 6ï¸âƒ£ Final Return

```js
return sentinel.next;
```

**Why?**

* Agar original head delete ho gaya ho
  ğŸ‘‰ New head yahin se milega

---

## ğŸ” Dry Run (Quick)

### Input

```
head = 6 â†’ 6 â†’ 1 â†’ 2
val = 6
```

### Steps

```
sentinel â†’ 6 â†’ 6 â†’ 1 â†’ 2
prev = sentinel
```

* `prev.next = 6` â†’ delete
* `prev.next = 6` â†’ delete again
* `prev.next = 1` â†’ move prev
* `prev.next = 2` â†’ move prev

### Output

```
1 â†’ 2
```

---

## âš ï¸ Common Mistakes (Avoid These)

âŒ Directly head ko modify karna
âŒ Head delete ke liye alag logic
âŒ `prev = prev.next` deletion ke baad (BUG)

---

## â± Complexity

| Type  | Complexity |
| ----- | ---------- |
| Time  | **O(n)**   |
| Space | **O(1)**   |

---

## ğŸ¯ Interview Ready Explanation (One Shot)

> â€œI use a sentinel node before the head to handle deletions uniformly.
> I traverse using a `prev` pointer and delete nodes by skipping `prev.next` when its value matches.
> This avoids special handling for head deletion.â€

---

## ğŸ§  Memory Trick

```
Sentinel lagao â†’ prev rakho â†’ prev.next delete karo
```
*/